[["index.html", "Introduction à R et aux statistiques en sciences sociales Chapitre 1 Remarques préliminaires 1.1 Installer R 1.2 Se retrouver à l’intérieur de ce syllabus", " Introduction à R et aux statistiques en sciences sociales Lev Lhommeau 2023-02-15 Chapitre 1 Remarques préliminaires Ceci est une introduction au langage de programmation R et à l’analyse statistique en sciences sociales. Ce syllabus s’adresse aux étudiants en sciences sociales, telles que la science politique, la sociologie et la communication, ainsi qu’à toute personne qui souhaite découvrir les bases de l’analyse statistique des phénomènes sociaux avec R. Ce syllabus veut contribuer à combler une lacune dans les publications existantes en langue française: il existe certes de très bons ouvrages théoriques d’introduction aux statistiques à l’usage des sciences sociales, tout comme il existe de bons ouvrages d’introduction à la programmation avec R. En revanche, une introduction pratique à l’analyse des phénomènes sociaux avec R fait encore défaut. C’est cette lacune que vise la présente introduction. Ce syllabus se fonde sur les travaux pratiques que j’assure sous la direction de Philippe Bocquier et Bruno Schoumaker à l’UCLouvain. Au vu du public cible, les concepts mathématiques et statistiques mobilisés dans cette introduction sont tout à fait abordables. Cette introduction essayera de faire au maximum l’économie de formules mathématiques et si elles sont indispensables, elles s’efforcera de les “traduire” en langue française. Il est cependant préférable, si le lecteur ne dispose pas de connaissances en statistiques, d’accompagner la lecture de ce syllabus de la lecture d’un manuel de statistiques ou du suivi d’un cours de statistiques. À cette fin, l’on peut conseiller en langue française, les ressources et ouvrages suivants (liste non exhaustive): Masuy-Stroobant &amp; Costa (2013): Analyser les données en sciences sociales. De la préparation des données à l’analyse multivariée, Bruxelles: P.I.E. Peter Lang. Cette introduction a vocation à être accessible à des personnes sans aucune expérience en programmation. Aucun prérequis en programmation n’est donc requis pour la suivre. Elle ne prétend pas à l’exhaustivité, mais souhaite donner un premier aperçu des statistiques en sciences sociales et des possibilités qu’offre le langage de programmation R. Vu qu’il s’agit d’une introduction aux statistiques, les autres usages de R, notamment pour les présentations (avec R Markdown ou Shiny) et l’automatisation de certaines tâches, ne seront pas traités. Si vous cherchez une introduction spécifique à la programmation en R en langue française, nous vous conseillons, l’ouvrage suivant: Vincent Goulet: Introduction à la programmation en R, (téléchargez le ici) Notons enfin, que nous avons fait le choix de montrer, outre le R de base, les méthodes issues du package tydiverse. Tydiverse est ce qu’on appelle un “dialecte” dans une langue de programmation. Un “dialecte” modifie une langue de programmation sans l’altérer fondamentalement. Pourquoi ajouter un “dialecte” à cette introduction? Le R de base ne suffit-il pas? Le tydiverse est très utilisé et il est donc plus qu’utile de le connaître si l’on souhaite se lancer dans R. De plus, le tydiverse avec ses package tels que dplyr et ggplot2 a grandement simplifié la manipulation des données et la réalisation de graphiques de qualité1. 1.1 Installer R Pour suivre cette introduction, veuillez installer le langage de programmation R et ensuite l’environnement de développement RStudio2 (bien dans cet ordre-là: installez d’abord R et ensuite RStudio Desktop) sur votre ordinateur. R est une langue de programmation libre, c’est-à-dire qu’elle est entièrement gratuite! Plus besoin d’acheter d’onéreuses licences pour des programmes d’analyse statistique payants tels que Stata, SPSS et SAS, bien souvent moins performants que R. RStudio est également gratuit dans sa version de base (RStudio Desktop), entièrement suffisante pour l’usage que nous allons en faire. Pour télécharger R, rendez-vous sur le site du CRAN et installez la dernière version de R pour votre système d’exploitation (Linux, Windows ou macOS): https://cran.r-project.org/ Pour télécharger RStudio rendez-vous sur le site de posit, l’entreprise qui développe RStudio, et installez la dernière version de RStudio pour votre système d’exploitation (Linux, Windows ou macOS): https://posit.co/ 1.2 Se retrouver à l’intérieur de ce syllabus Ce syllabus est composé de plusieurs chapitres qui abordent chacun des questions différentes. Le syllabus suit une progression: la complexité augmente avec les chapitres. Il est donc conseillé, surtout au début, de bien suivre l’ordre de celui-ci. Au fur et à mesure que vous avancerez, vous pourrez prendre davantage de libertés avec l’ordre dans lequel vous lisez les chapitres. Vous pouvez naviguer entre les chapitres et les sous-chapitres dans le volet de gauche. Vous pouvez, par ailleurs, naviguer entre les chapitres en appuyant sur les touches de gauche et de droite. Vous pouvez télécharger la version PDF et epub de ce syllabus en cliquant sur l’icône de téléchargement en haut de la page3. Les codes R à introduire se trouvent dans des encadrés comme celui-ci: # Le signe # marque un commentaire qui sera ignoré par R. #Si vous voulez afficher le fameux &quot;Hello World&quot;, vous pouvez le faire ainsi: print(&quot;Hello world!&quot;) #Ou ainsi: message(&quot;Hello world!&quot;) Si vous passez votre souris sur cet encadré, vous verrez apparaître, en haut à droite de l’encadré, une icône vous permettant de copier son contenu. Celui-ci pourra être collé dans votre code R puis exécuté. Si vous copiez ce code dans votre R Code puis l’exécutez (ou le copiez directement dans votre console puis appuyez sur la touche “Entrée” de votre clavier), voilà ce qui devrait apparaître dans votre console: ## [1] &quot;Hello world!&quot; ## Hello world! Si vous avez des questions ou des remarques, n’hésitez pas à me contacter: lev.lhommeau@uclouvain.be / lhommeau@gmail.com4. Si vous voulez lire une introduction en français plus complète au tidyverse nous renvoyons à l’ouvrage “Introduction à R et au tidyverse” de Julien Barnier.↩︎ RStudio est un environnement de développement spécialisé pour R, mais il peut également exécuter le langage de programmation plus généraliste Python. Vous pouvez également utiliser R sans environnement de développement ou avec un autre environnement que RStudio, tel que VSCode. RStudio est cependant l’environnement le plus utilisé pour coder en R et certainement le plus adapté aux débutants.↩︎ Notez que pas toutes les fonctions “interactives” de ce syllabus ne pourront pas être maintenus au format PDF et epub et que des difficultés de mise en page ne sont pas exclues.↩︎ Si je ne réponds pas à l’une de ces adresses, essayez de me contacter par l’autre.↩︎ "],["Priseenmain.html", "Chapitre 2 Prise en main de R 2.1 Commandes dans R 2.2 Fonctions et aide dans R 2.3 Espace de travail (working directory) 2.4 Installer et lancer des packages (bibliothèques) 2.5 Objets et environnement dans R 2.6 Importer et enregistrer des données 2.7 Fermer R", " Chapitre 2 Prise en main de R 2.1 Commandes dans R Vous vous demandez peut-être comment exécuter des commandes dans R. Si vous utilisez RStudio, vous avez deux possibilités. Vous pouvez indiquer le code directement dans la console qui se trouve dans l’onglet “Console”. une fois que la commande est introduite, appuyez sur la touche Entrée de votre clavier pour la soumettre à l’interpréteur de R. Cependant, cette manière ne sera pas votre moyen principal de soumettre des commandes à R. Vous allez plutôt utiliser des fichiers R Script dans lesquels vous noterez votre code: pour créer un nouveau fichier R Script, cliquez en haut à gauche dans RStudio sur l’icône représentant une feuille blanche avec un signe plus (+) sur fond vert et choisissez R Script dans le menu déroulant. Un fichier R Script est un document texte rassemblant l’ensemble des commandes que vous souhaitez soumettre à R. C’est un peu comme une “recette” où chaque commande correspond à un ingrédient ou une manipulation à faire pour obtenir le plat désiré. Sauf, bien entendu, que le plat désiré ne sera pas une mousse au chocolat ou un rôti de bœuf, mais le résultat d’un calcul, d’une manipulation de données, d’une analyse statistique ou une représentation graphique. Ce fichier R Script peut être enregistré sous un nom de votre choix suivi du suffixe “.R” (par exemple: “Analyse.R”). Cela vous permet de commenter et de reproduire les commandes que vous avez faites: si vous indiquiez vos commandes uniquement dans la console, vous pourriez que difficilement reproduire vos manipulations et analyses. Or, la reproductibilité est un critère essentiel de la scientificité. Par ailleurs, le code que vous avez écrit peut être réutilisé lors d’analyses futures. Cela vous fera gagner du temps! Mais comment exécuter les commandes que vous avez notées dans votre fichier de R Script? Il suffit de placer le curseur sur une commande et d’appuyer sur la flèche verte “Run” qui se situe au-dessus à droite de l’onglet où se trouve votre code. Vous pouvez aussi appuyer sur les touches “Contrôle + Entrée” de votre clavier. Par ailleurs, vous pouvez sélectionner une partie de votre code, puis exécuter cette partie du code de la même manière. 2.2 Fonctions et aide dans R Comme Excel (ou d’autres langues de programmation tels que Python ou C), R dispose de fonctions que vous allez pouvoir utiliser pour mener vos analyses statistiques et manipuler vos données. En informatique, une fonction est un programme qui exécute une (suite de) commande(s) dont elle retourne un résultat et que l’on peut réutiliser dans d’autres programmes. Les fonctions en R sont composées de leur nom5, suivi d’une parenthèse dans laquelle vous pourrez indiquer, le cas échéant, les arguments séparés par des virgules. Ainsi, si vous voulez connaitre la moyenne de la suite \\(A=\\{0,1,2,3,4,5,6,7,8,9,10\\}\\), vous pouvez utiliser la fonction mean(). Avant il faut créer le vecteur6 suite_a: #Nous créons la suite A allant de 0 à 10 et la nommons suite_a dans R: suite_a&lt;-c(0,1,2,3,4,5,6,7,8,9,10) #À l&#39;aide de la fonction mean(), nous calculons la moyenne de cette suite: mean(suite_a) ## [1] 5 L’objet suite_a contenant la suite \\(A\\) est l’argument de la fonction mean() que l’on note dans la parenthèse de la fonction. Comme vous pouvez le voir, la moyenne de cette suite \\(A\\) est de 5. Si vous avez besoin d’aide concernant une fonction dans R, écrivez la fonction précédée de “?”. Par exemple: ?setwd Dans RStudio, dans l’onglet “Help” en bas à droite, s’affiche alors l’aide. Vous pouvez également sélectionner une fonction et appuyer sur la touche “F1” de votre clavier. Outre les fonctions déjà existantes dans R et ses packages, vous pouvez définir vos propres fonctions. Celles-ci vous permettent de réaliser ce dont vous avez besoin sur mesure (analyse statistique, transformation de données, etc.). Cela peut être réalisé de manière assez simple dans R7. 2.3 Espace de travail (working directory) Lorsque l’on travaille avec R, il faut définir un espace de travail. C’est le dossier où R sauvegardera et charge les fichiers et bases de données avec lesquels vous travaillez. Si vous ne le déterminez pas, R choisit un dossier par défaut. Sur un ordinateur Windows, cela sera bien souvent le dossier “Documents”. Nous vous conseillons de créer un dossier dédié à votre travail en R et de définir celui-ci comme répertoire de travail. Si vous aviez créé un dossier “Espace_R” dans un dossier “Revisions” sur votre disque dur C, vous soumettriez le code suivant à R pour en faire votre espace de travail: setwd(&quot;C:/Revisions/Espace_R&quot;) # Indiquez le chemin du dossier qui doit être votre répertoire de travail Vous aurez remarqué que le chemin d’accès et les dossiers sont entre guillemets. Par ailleurs, dans R, les chemins d’accès entre dossiers (“Revision”) et sous-dossiers (“Espace_R”) sont séparés par des barres obliques (/), comme pour une division. Dans Windows, les chemins d’accès sont notés par des barres obliques inversées (\\). Il faut donc corriger cela lorsque vous copiez des chemins d’accès dans R. Sous Windows, vous pouvez aussi choisir manuellement le dossier dans lequel se trouve votre espace de travail: setwd(choose.dir()) # Indiquez le chemin du dossier qui doit être votre répertoire de travail Si vous lancez ce code, une fenêtre s’ouvre dans laquelle vous pourrez cliquer sur le dossier que vous souhaitez déterminer en tant que dossier de travail. Malheureusement, cela fonctionne uniquement sous Windows et pas sous Linux et macOS. Que votre système d’exploitation soit Linux, macOS ou Windows, vous pouvez définir votre espace de travail grâce aux menus de RStudio. Allez sur le menu “Session” puis choisissez “Set Working Directory” dans le menu déroulant. Parmi les options disponibles cliquez sur “Choose Directory”. Une fenêtre s’ouvre alors dans laquelle vous pourrez choisir le fichier de votre choix pour déterminer l’emplacement de votre espace de travail. 2.4 Installer et lancer des packages (bibliothèques) Comme d’autres langues de programmation, R dispose d’un grand nombre de packages8. Ceux-ci enrichissent le langage de nouvelles fonctions qui n’étaient pas encore présentes dans sa version initiale. R est particulièrement riche en packages. Sur CRAN, le répertoire “officiel” de R, \\(19136\\) packages étaient répertoriés en janvier 2023. Pour installer un package, il y a la commande générique install.packages(). Lors de cette formation, nous allons beaucoup utiliser des packages issus du tydiverse, un ensemble de packages, permettant de manipuler les données et de les représenter graphiquement. Cette suite de packages est particulièrement populaire et très largement utilisée. Nous allons donc installer cet ensemble de packages avec la commande install.packages(): install.packages(tidyverse, dependencies=T) #l&#39;argument &quot;dependencies=T&quot; permet #d&#39;installer automatiquement tous les packages dont à besoin le package #que l&#39;on installe pour fonctionner correctement. Installer un package ne suffit pas pour l’utiliser. Il doit être chargé à chaque fois que R est fermé puis redémarré. Cela se fait avec la commande library(). Lançons donc le package tidyverse: library(tidyverse) Le package est à présent chargé et peut être utilisé. Si R vous retourne une erreur lorsque vous chargez un package, cela est souvent dû au fait que le package demandé n’est pas (correctement) installé (vérifiez aussi de l’avoir orthographié correctement et d’avoir respecté la casse). Si vous lancez une fonction et que celle-ci ne s’exécute pas (et renvoie une erreur), vérifiez que le package à laquelle elle appartient est bien chargé. Vous verrez cela dans l’onglet “Packages” en bas à droite de RStudio: si le package apparaît dans la liste, c’est qu’il est installé. S’il est coché, c’est qu’il est chargé. S’il n’apparaît pas dans la liste, installez-le. S’il n’est pas coché, lancez-le. Vous pouvez le lancer avec la commande library(), mais vous pouvez aussi la lancer en cochant le package dans l’onglet. Une façon plus simple d’installer et de charger les packages est le package pacman. Celui-ci permet d’installer les packages et de les lancer en une seule commande: p_load. Cette commande vérifie si un package est installé: s’il est installé, il le lance, s’il ne l’est pas, il l’installe, puis le lance. Cela peut rendre le lancement de packages plus facile et rapide. Par ailleurs, cela permet de plus facilement partager son code: l’interlocuteur peut exécuter votre code sans devoir vérifier s’il a installé les packages que vous utilisez: if (!require(&quot;pacman&quot;)) install.packages(&quot;pacman&quot;) #Cela vérifie #si le package pacman est installé. #S&#39;il ne l&#39;est pas, il est installé. pacman::p_load(tidyverse) #On lance le package tidyverse s&#39;il est installé, #sinon on l&#39;installe puis le lance automatiquement. Si vous voulez lancer plusieurs packages en même temps, il suffit de les ajouter à la suite, séparés par des virgules, entre les parenthèses suivant la fonction p_load. Ainsi, si nous voulions charger les packages du tydiverse, ainsi que le package DT9. if (!require(&quot;pacman&quot;)) install.packages(&quot;pacman&quot;) #Cela vérifie #si le package pacman est installé. #S&#39;il ne l&#39;est pas, il est installé. pacman::p_load(tidyverse, DT) #La liste des packages, séparés #par des virgules, que l&#39;on souhaite #charger et, si nécessaire, installer. Vous pouvez aligner à la suite autant de packages que vous le souhaiter en les séparant par des virgules. Dans ce syllabus, nous allons utiliser cette méthode avec pacman pour éviter de devoir vérifier si certains packages sont installés avant de les lancer. 2.5 Objets et environnement dans R R est une langue de programmation orientée objet. Cela signifie que l’on définit des objets (bases de données, valeurs, fonctions, etc.) que l’on fait interagir les uns avec les autres pour obtenir le résultat escompté10. Vous pouvez vous imaginer cela un peu comme différentes pièces de “Légo” que vous assemblez pour construire un château à votre goût. Dans R, l’on crée un objet avec le symbole “&lt;-”, une flèche pointant vers la gauche. La flèche montre vers le nom de l’objet à créer à gauche et à droite l’on définit le contenu de cet objet (valeur, vecteur, matrice, etc.). L’on peut ainsi créer l’objet bombe_atomique qui contient la valeur \\(1000^2\\): bombe_atomique &lt;- 1000^2 # À gauche: le nom de l&#39;objet (bombe_atomique), à droite la valeur #qu&#39;elle contient (1000^2) bombe_atomique #Maintenant, on se fait afficher le contenu de cet objet dans la console. ## [1] 1e+06 La valeur de l’objet bombe_atomique apparaît dans la console. Par ailleurs, le nom de l’objet apparaît en haut à droite dans l’onglet “Environement” de RStudio. Si vous avez calculé la moyenne de la suite \\(A\\) dans la section Fonctions et aide dans R, vous y verrez aussi l’objet suite_a. Dans R un environnement11 est un espace où les objets sont enregistrés vous permettant de les analyser et de les manipuler. Vous aurez peut-être remarqué que la valeur de l’objet bombe_atomique est affichée en notation scientifique: ## [1] 1e+06 Vous pouvez désactiver cet affichage avec la commande suivante: options(scipen=999) Vérifiez à nouveau la valeur de l’objet bombe_atomique: bombe_atomique ## [1] 1000000 Comme vous pouvez le voir, la notation scientifique à disparue. Cela peut vous faciliter la lecture des résultats de vos analyses! 2.6 Importer et enregistrer des données R dispose de nombreuses fonctions intégrées pour importer des données sous différents formats (read.table, read.delim, read.csv, etc.). Il y a, par ailleurs, un certain nombre de packages qui ajoutent de nouvelles fonctions et d’autres formats de données que l’on peut intégrer. Ainsi, le package readr, appartenant à “l’univers” tydiverse étant ainsi automatiquement chargé si vous chargez le tydiverse (voir ici), ajoute des fonctions assez intéressantes pour charger des données au format texte (csv, txt): read_delim, read_csv, read_csv2, etc. De même, le package readxl permet de charger des fichiers au format Excel dans R. Bien que ce package appartienne également à “l’univers” tydiverse, le package readr doit être chargé séparément. Un troisième package issu de cet “univers” est le package haven: il permet de charger des bases de données enregistrées au format des logiciels statistiques payants SAS, Stata et SPSS. En effet, beaucoup de bases de données sont enregistrées dans l’un de ces formats qui ont l’avantage, contrairement aux formats CSV et Excel, de pouvoir notamment enregistrer des libellées des variables et des valeurs. Le package haven permet de préserver ces avantages lorsque l’on importe les données dans R: if (!require(&quot;pacman&quot;)) install.packages(&quot;pacman&quot;) #Cela vérifie #si le package pacman est installé. #S&#39;il ne l&#39;est pas, il est installé. pacman::p_load(readxl,haven) #On lance les packages readxl et haven. Lors de cette introduction nous allons utiliser les données issues de l’Enquête sociale européenne/European social survey (ESS)12. Nous allons utiliser la version 9 de l’ESS (ESS 9), contenant des données récoltées en 2018. Les données de l’ESS sont mises à disposition aux formats SPSS (avec le suffixe “.sav”), Stata (avec le suffixe “.dta”) et SAS (avec le suffixe “.sas”). Nous allons télécharger les données de l’ESS au format SPSS (avec le suffixe “.sav”). Pour pouvoir télécharger les données, il faut s’inscrire sur le site de l’ESS. Cette inscription est entièrement gratuite. Les données de l’ESS peuvent être librement utilisées à des fins non commerciales, notamment pour la recherche et l’enseignement. Nous vous demanderons de vous inscrire sur le le site de l’ESS et de télécharger les données: téléchargez les données de l’ESS 9 (ESS Round 9) pour tous les pays au format SPSS (fichier se terminant par “.sav”). Nous vous laissons suivre les indications sur le site (en anglais) pour vous inscrire et télécharger les données13. Il existe le package esssurvey qui permettait de télécharger directement les données de l’ESS dans R. Malheureusement, en raison de changements concernant l’accès aux données de l’ESS au cours de 2022, ce package ne fonctionne plus (janvier 2023). Une fois que vous avez téléchargé le fichier de l’ESS 9 (2018) au format SPSS (fichier se terminant par “.sav”), il faudra charger la base de données dans R. Pour cela, copiez le fichier dans le dossier dans lequel se trouve votre espace de travail R14. Notre fichier se nomme “ESS9e03_1.sav”. Adapter le nom du fichier, s’il porte un autre nom chez vous. Une fois que le fichier de l’ESS 9 se trouve dans votre espace de travail, indiquez le code suivant15: ESS9&lt;-read_sav(&quot;ESS9e03_1.sav&quot;) #Vous indiquez le nom de votre fichier #entre guillemets (&quot;&quot;). Si le fichier ne se #trouve pas dans votre espace de travail, vous #devrez indiquer tout le chemin d&#39;accès. Avec cette commande, vous avez chargé la base de données dans l’environnement de R. Vous l’avez nommé “ESS9”16. Elle apparaît dans l’onglet “Environement” en haut à droite de RStudio. Si vous utilisez le système d’exploitation Windows, vous pouvez aussi utiliser la commande choose.files à l’intérieur de la fonction read_sav. Lorsque vous exécutez cette commande, une fenêtre s’ouvre vous permettant de choisir manuellement le fichier à charger: ESS9&lt;-read_sav(choose.files()) Le fichier étant chargé dans l’environnement, vous pouvez l’étudier et le manipuler dans R. Sélectionnez l’objet et exécutez-le: ESS9 Dans votre console s’affichera alors un extrait de la base de données: ## # A tibble: 49,519 × 572 ## name essround edition prodd…¹ idno cntry dweight pspwght pweight anwei…² nwspol netus…³ netustm ppltrst pplfair pplhlp polintr pspps…⁴ ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr+lb&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl+&gt; &lt;dbl+l&gt; &lt;dbl+l&gt; &lt;dbl+l&gt; &lt;dbl+l&gt; &lt;dbl+&gt; &lt;dbl+l&gt; &lt;dbl+l&gt; ## 1 ESS9e03_1 9 3.1 17.02.… 27 AT [Aus… 0.581 0.218 0.302 0.0659 60 5 [Eve… 180 2 [2] 2 [2] 2 [2] 3 [Har… 3 [Som… ## 2 ESS9e03_1 9 3.1 17.02.… 137 AT [Aus… 1.06 0.413 0.302 0.125 10 5 [Eve… 20 7 [7] 8 [8] 7 [7] 2 [Qui… 3 [Som… ## 3 ESS9e03_1 9 3.1 17.02.… 194 AT [Aus… 1.38 2.27 0.302 0.686 60 4 [Mos… 180 5 [5] 7 [7] 7 [7] 4 [Not… 2 [Ver… ## 4 ESS9e03_1 9 3.1 17.02.… 208 AT [Aus… 0.993 0.386 0.302 0.117 45 5 [Eve… 120 3 [3] 9 [9] 5 [5] 3 [Har… 2 [Ver… ## 5 ESS9e03_1 9 3.1 17.02.… 220 AT [Aus… 0.377 1.03 0.302 0.312 30 1 [Nev… NA 5 [5] 8 [8] 4 [4] 2 [Qui… 1 [Not… ## 6 ESS9e03_1 9 3.1 17.02.… 254 AT [Aus… 1.48 0.576 0.302 0.174 45 2 [Onl… NA 8 [8] 7 [7] 6 [6] 2 [Qui… 2 [Ver… ## 7 ESS9e03_1 9 3.1 17.02.… 290 AT [Aus… 0.992 0.721 0.302 0.218 60 1 [Nev… NA 6 [6] 1 [1] 3 [3] 4 [Not… 2 [Ver… ## 8 ESS9e03_1 9 3.1 17.02.… 301 AT [Aus… 0.310 0.130 0.302 0.0393 30 1 [Nev… NA 7 [7] 7 [7] 7 [7] 3 [Har… 1 [Not… ## 9 ESS9e03_1 9 3.1 17.02.… 305 AT [Aus… 1.23 1.77 0.302 0.535 30 5 [Eve… 120 2 [2] 9 [9] 9 [9] 3 [Har… 1 [Not… ## 10 ESS9e03_1 9 3.1 17.02.… 400 AT [Aus… 0.459 0.743 0.302 0.224 25 4 [Mos… 360 7 [7] 4 [4] 4 [4] 4 [Not… 2 [Ver… ## # … with 49,509 more rows, 554 more variables: actrolga &lt;dbl+lbl&gt;, psppipla &lt;dbl+lbl&gt;, cptppola &lt;dbl+lbl&gt;, trstprl &lt;dbl+lbl&gt;, trstlgl &lt;dbl+lbl&gt;, ## # trstplc &lt;dbl+lbl&gt;, trstplt &lt;dbl+lbl&gt;, trstprt &lt;dbl+lbl&gt;, trstep &lt;dbl+lbl&gt;, trstun &lt;dbl+lbl&gt;, vote &lt;dbl+lbl&gt;, prtvtcat &lt;dbl+lbl&gt;, ## # prtvtdbe &lt;dbl+lbl&gt;, prtvtdbg &lt;dbl+lbl&gt;, prtvtgch &lt;dbl+lbl&gt;, prtvtbcy &lt;dbl+lbl&gt;, prtvtecz &lt;dbl+lbl&gt;, prtvede1 &lt;dbl+lbl&gt;, prtvede2 &lt;dbl+lbl&gt;, ## # prtvtddk &lt;dbl+lbl&gt;, prtvtgee &lt;dbl+lbl&gt;, prtvtees &lt;dbl+lbl&gt;, prtvtdfi &lt;dbl+lbl&gt;, prtvtdfr &lt;dbl+lbl&gt;, prtvtcgb &lt;dbl+lbl&gt;, prtvtahr &lt;dbl+lbl&gt;, ## # prtvtfhu &lt;dbl+lbl&gt;, prtvtcie &lt;dbl+lbl&gt;, prtvtcis &lt;dbl+lbl&gt;, prtvtcit &lt;dbl+lbl&gt;, prtvblt1 &lt;dbl+lbl&gt;, prtvblt2 &lt;dbl+lbl&gt;, prtvblt3 &lt;dbl+lbl&gt;, ## # prtvtalv &lt;dbl+lbl&gt;, prtvtme &lt;dbl+lbl&gt;, prtvtgnl &lt;dbl+lbl&gt;, prtvtbno &lt;dbl+lbl&gt;, prtvtdpl &lt;dbl+lbl&gt;, prtvtcpt &lt;dbl+lbl&gt;, prtvtrs &lt;dbl+lbl&gt;, ## # prtvtcse &lt;dbl+lbl&gt;, prtvtfsi &lt;dbl+lbl&gt;, prtvtdsk &lt;dbl+lbl&gt;, contplt &lt;dbl+lbl&gt;, wrkprty &lt;dbl+lbl&gt;, wrkorg &lt;dbl+lbl&gt;, badge &lt;dbl+lbl&gt;, … Comme pour d’autres logiciels statistiques, les colonnes représentent les variables et les lignes les observations. Ici, une vingtaine de variables sont affichées (sur \\(572\\)). De même, les dix premières observations (sur \\(49519\\)) sont affichées17. Si vous voulez voir l’ensemble de la base de données, vous pouvez utiliser la fonction View()18: View(ESS9) Si vous voulez enregistrer la base de données sous un format R, utilisez le format RDS. Celui-ci vous permet d’enregistrer un objet R. La base de données de l’ESS étant chargé sous le nom “ESS9” comme objet R dans l’environnement global il vous suffira d’exécuter la commande saveRDS() pour l’enregistrer. Dans cette commande vous indiquez le nom de l’objet R à enregistrer en tant que premier argument. Ensuite, vous indiquez, séparé par une virgule, comme second argument, le nom sous lequel vous voulez enregistrer l’objet. Ce nom doit être indiqué entre guillemets. Ici, nous voulons enregistrer l’objet “ESS9” sous le nom “ESS9.RDS”, afin de le réutiliser lors du prochain chapitre. Exécutez donc le code suivant: saveRDS(ESS9,&quot;ESS9.RDS&quot;) Le fichier “ESS9.RDS” contenant votre base de données est alors enregistré dans votre espace de travail. Vous pourrez la charger ensuite pour continuer à travailler avec. C’est ce que nous allons faire dans le prochain chapitre portant sur les distributions. 2.7 Fermer R Lorsque vous fermez R, RStudio va vous proposer d’enregistrer l’environnement global. Si vous l’acceptez, un fichier contenant tous les objets se trouvant dans votre environnement global sera enregistré dans votre espace de travail. Lorsque vous rouvrez R plus tard, tous les objets que vous aviez dans votre espace de travail au moment de la fermeture de R seront à nouveau accessibles. Cela vous permettra de reprendre votre travail où vous en étiez avant de fermer R. Si vous n’enregistrez pas l’espace de travail, il sera vierge lorsque vous ouvrez R à nouveau. Il faudra exécuter les commandes de la dernière session pour arriver au même stade qu’avant la fermeture. Attention: même si vous enregistrez l’espace de travail, il faudra relancer les packages que vous souhaitez utiliser lorsque vous rouvrez R. Lorsque vous ouvrez RStudio les fichier R Script qui étaient ouverts lorsque vous avez fermé RStudio s’ouvrent automatiquement. Attention: R est sensible à la casse: “Mean” est différent de “mean”. Soyeuz fonc toujours très attentif à la casse lorsque vous codez en R.↩︎ Pour savoir comment créer des vecteurs en R, nous renvoyons à la page suivante: http://www.sthda.com/french/wiki/les-vecteurs-vector.↩︎ Ce syllabus contient des exemples de fonctions créés, cependant cela ne fait pas partie de ses objets principaux. Nous renvoyons donc à d’autres ouvrages à ce sujet.↩︎ En français, l’on parle de bibliothèques. Nous alignons cependant ce syllabus sur l’usage en anglais que l’on retrouve dans R. Nous parlerons donc de package(s).↩︎ Le package DT permet de créer des tableaux interactifs assez pratiques pour se faire une idée des données. Attention cependant, car les bases de données avec un nombre trop important de lignes (des dizaines de milliers) peuvent faire “crasher” R.↩︎ Une introduction un peu technique à la programmation orientée objet (POO) se trouve ici: https://hdd34.developpez.com/cours/artpoo/↩︎ R connaît plusieurs environnements. L’environnement où est enregistré l’objet définit sa portée, c’est-à-dire dans quelles circonstances les objets sont accessibles. Dans ce syllabus, nous utiliserons consciemment (pratiquement) exclusivement l’environnement global dénommé “.GlobalEnv”. Vu qu’il s’agit d’une introduction, nous ne nous attardons pas sur ce point.↩︎ Davantage d’informations sur l’Enquête sociale européenne peuvent être trouvées sur son site: https://www.europeansocialsurvey.org/about/↩︎ Si vous suivez un enseignement avec Lev Lhommeau, il se peut que ces données vous soient mises à disposition dans ce cadre.↩︎ Il est possible de charger des fichiers ne se trouvant pas dans votre espace de travail. Cela nécessite cependant d’indiquer l’ensemble du chemin d’accès dans R, ce qui peut être laborieux.↩︎ L’exécution de cette commande nécessite le chargement préalable du package “haven”, comme indiqué plus haut.↩︎ Vous aurez aussi pu la nommer différemment. Pour cela il suffit de changer le nom à gauche de la flèche (&lt;-).↩︎ Cet affichage est le réglage par défaut d’un tibble, une forme spéciale de base données dans R. Si vous avez une base de données par défaut (data.frame) de R, cela s’affichera un peu différemment. Pour plus de détails en français: https://juba.github.io/tidyverse/06-tidyverse.html↩︎ Mais attention, la base de données étant grande avec près de \\(500000\\) observations, cela peut prendre un certain temps.↩︎ "],["charge_code_filtrer.html", "Chapitre 3 Charger des bases de données et les filtrer 3.1 Charger des données au format R (.RDS) 3.2 Explorer les données: créer un codebook interactif 3.3 Filtrer les données", " Chapitre 3 Charger des bases de données et les filtrer Dans ce chapitre, nous allons voir comment charger des bases de données, créer des Codebook et filtrer des données. L’objectif est de créer une base de données reprenant seulement les observations belges. Cela nous sera nécessaire pour analyser les salaires en Belgique au prochain chapitre. Si vous avez éteint R depuis le dernier chapitre, il faudra lancer les packages avant de reprendre les analyses. À cette fin, exécutez les commandes suivantes: if (!require(&quot;pacman&quot;)) install.packages(&quot;pacman&quot;) #Cela vérifie #si le package pacman est installé. #S&#39;il ne l&#39;est pas, il est installé. pacman::p_load(tidyverse, descr, rcompanion, codebook, DT, sjPlot, labelled) #On lance les packages 3.1 Charger des données au format R (.RDS) Pour commencer nos analyses, il faut charger les données. Dans le chapitre précédent, nous avons vu comment importer des données depuis le format SPSS (suffixe .sav) et comment les enregistrer au format “RDS” de R. Nous avions enregistré la base de données de ’l’Enquête sociale européenne/European social survey (ESS) “ESS 9” sous le nom “ESS9.RDS”. Nous allons à présent charger ce fichier pour continuer nos analyses avec cette base de données. Assurez-vous que le fichier “ESS9.RDS” se trouve dans votre espace de travail. Si vous ne l’avez pas, effectuez les étapes décrites dans le chapitre précédent19. Chargez donc le fichier à l’aide de la commande readRDS(): ESS9&lt;-readRDS(&quot;ESS9.RDS&quot;)#Vous nommez la base de données ESS9 Lorsque vous chargez une base de données (ou un autre objet R) à l’aide de la fonction “readRDS()”, il faut lui attribuer un nom sous lequel le charger dans l’espace de travail. Ici nous le faisons en plaçant une flèche (&lt;-) à gauche de la fonction et en indiquant le nom de l’objet au bout de cette flèche: ESS9. Si vous ne nommez pas l’objet, et écrivez simplement la commande sans lui attribuer de nom, la base de données apparaîtra certes dans la sortie de la console, mais ne sera pas enregistrée dans l’environnement global. Vous ne pourrez alors pas faire d’analyse avec cette base de données. Assurez-vous que l’objet est bien chargé en vérifiant s’il apparaît dans l’onglet “Environment” à droite dans RStudio. Par ailleurs, faites-vous afficher l’objet en exécutant le code suivant: ESS9 #En exécutant le nom de l&#39;objet, il s&#39;affiche ## # A tibble: 49,519 × 572 ## name essround edition prodd…¹ idno cntry dweight pspwght pweight anwei…² nwspol netus…³ netustm ppltrst pplfair pplhlp polintr pspps…⁴ ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr+lb&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl+&gt; &lt;dbl+l&gt; &lt;dbl+l&gt; &lt;dbl+l&gt; &lt;dbl+l&gt; &lt;dbl+&gt; &lt;dbl+l&gt; &lt;dbl+l&gt; ## 1 ESS9e03_1 9 3.1 17.02.… 27 AT [Aus… 0.581 0.218 0.302 0.0659 60 5 [Eve… 180 2 [2] 2 [2] 2 [2] 3 [Har… 3 [Som… ## 2 ESS9e03_1 9 3.1 17.02.… 137 AT [Aus… 1.06 0.413 0.302 0.125 10 5 [Eve… 20 7 [7] 8 [8] 7 [7] 2 [Qui… 3 [Som… ## 3 ESS9e03_1 9 3.1 17.02.… 194 AT [Aus… 1.38 2.27 0.302 0.686 60 4 [Mos… 180 5 [5] 7 [7] 7 [7] 4 [Not… 2 [Ver… ## 4 ESS9e03_1 9 3.1 17.02.… 208 AT [Aus… 0.993 0.386 0.302 0.117 45 5 [Eve… 120 3 [3] 9 [9] 5 [5] 3 [Har… 2 [Ver… ## 5 ESS9e03_1 9 3.1 17.02.… 220 AT [Aus… 0.377 1.03 0.302 0.312 30 1 [Nev… NA 5 [5] 8 [8] 4 [4] 2 [Qui… 1 [Not… ## 6 ESS9e03_1 9 3.1 17.02.… 254 AT [Aus… 1.48 0.576 0.302 0.174 45 2 [Onl… NA 8 [8] 7 [7] 6 [6] 2 [Qui… 2 [Ver… ## 7 ESS9e03_1 9 3.1 17.02.… 290 AT [Aus… 0.992 0.721 0.302 0.218 60 1 [Nev… NA 6 [6] 1 [1] 3 [3] 4 [Not… 2 [Ver… ## 8 ESS9e03_1 9 3.1 17.02.… 301 AT [Aus… 0.310 0.130 0.302 0.0393 30 1 [Nev… NA 7 [7] 7 [7] 7 [7] 3 [Har… 1 [Not… ## 9 ESS9e03_1 9 3.1 17.02.… 305 AT [Aus… 1.23 1.77 0.302 0.535 30 5 [Eve… 120 2 [2] 9 [9] 9 [9] 3 [Har… 1 [Not… ## 10 ESS9e03_1 9 3.1 17.02.… 400 AT [Aus… 0.459 0.743 0.302 0.224 25 4 [Mos… 360 7 [7] 4 [4] 4 [4] 4 [Not… 2 [Ver… ## # … with 49,509 more rows, 554 more variables: actrolga &lt;dbl+lbl&gt;, psppipla &lt;dbl+lbl&gt;, cptppola &lt;dbl+lbl&gt;, trstprl &lt;dbl+lbl&gt;, trstlgl &lt;dbl+lbl&gt;, ## # trstplc &lt;dbl+lbl&gt;, trstplt &lt;dbl+lbl&gt;, trstprt &lt;dbl+lbl&gt;, trstep &lt;dbl+lbl&gt;, trstun &lt;dbl+lbl&gt;, vote &lt;dbl+lbl&gt;, prtvtcat &lt;dbl+lbl&gt;, ## # prtvtdbe &lt;dbl+lbl&gt;, prtvtdbg &lt;dbl+lbl&gt;, prtvtgch &lt;dbl+lbl&gt;, prtvtbcy &lt;dbl+lbl&gt;, prtvtecz &lt;dbl+lbl&gt;, prtvede1 &lt;dbl+lbl&gt;, prtvede2 &lt;dbl+lbl&gt;, ## # prtvtddk &lt;dbl+lbl&gt;, prtvtgee &lt;dbl+lbl&gt;, prtvtees &lt;dbl+lbl&gt;, prtvtdfi &lt;dbl+lbl&gt;, prtvtdfr &lt;dbl+lbl&gt;, prtvtcgb &lt;dbl+lbl&gt;, prtvtahr &lt;dbl+lbl&gt;, ## # prtvtfhu &lt;dbl+lbl&gt;, prtvtcie &lt;dbl+lbl&gt;, prtvtcis &lt;dbl+lbl&gt;, prtvtcit &lt;dbl+lbl&gt;, prtvblt1 &lt;dbl+lbl&gt;, prtvblt2 &lt;dbl+lbl&gt;, prtvblt3 &lt;dbl+lbl&gt;, ## # prtvtalv &lt;dbl+lbl&gt;, prtvtme &lt;dbl+lbl&gt;, prtvtgnl &lt;dbl+lbl&gt;, prtvtbno &lt;dbl+lbl&gt;, prtvtdpl &lt;dbl+lbl&gt;, prtvtcpt &lt;dbl+lbl&gt;, prtvtrs &lt;dbl+lbl&gt;, ## # prtvtcse &lt;dbl+lbl&gt;, prtvtfsi &lt;dbl+lbl&gt;, prtvtdsk &lt;dbl+lbl&gt;, contplt &lt;dbl+lbl&gt;, wrkprty &lt;dbl+lbl&gt;, wrkorg &lt;dbl+lbl&gt;, badge &lt;dbl+lbl&gt;, … Si vous n’avez pas enregistré le fichier dans votre espace de travail, mais que vous voulez malgré tout le charger, vous pouvez indiquer le sentier entier en argument comme montré dans la section Espace de travail. Si vous utilisez Windows, vous pouvez aussi utiliser la fonction choose.files(), comme montré dans la section Importer et enregistrer des données: ESS9&lt;-readRDS(choose.files()) Une fois les données importées, nous pouvons avancer sur les manipulations et les analyses. 3.2 Explorer les données: créer un codebook interactif Nous avons la base de données de l’ensemble du “round” 9 de l’Enquête sociale européenne/European social survey (ESS). Quels pays a-t-il dans cette base de données? Pour répondre à cette question, il faut savoir dans quelle variable cette information est stockée. Un codebook nous permet de répondre à cette question. Un codebook est un document résumant les variables avec leurs noms, leurs libellés et les libellés des variables. Des logiciels tels que Stata et SPSS proposent d’office cette possibilité. Ainsi SPSS propose l’onglet “Variable View” qui permet de se faire une idée des variables. À première vue, R semble moins convivial pour afficher les variables. Cependant, rien n’est plus faux: en effet, l’on peut créer un codebook à l’aide du package codebook. Ce codebook devient interactif, si l’on le combine avec la fonction datatable du package DT. Il faut tout d’abord créer le codebook avec la fonction codebook_table. Nous l’appelons codebook_ESS9: codebook_ESS9 &lt;- codebook_table(ESS9) Ensuite, vous rendez ce codebook interactif avec la fonction datatable(). Ici, vous créez l’objet codebook_ESS9_DT: codebook_ESS9_DT &lt;- datatable(codebook_ESS9, options = list(scrollX = TRUE)) Notons que chez vous, il devrait suffire d’exécuter le code ainsi, sans ajouter l’option pour ajouter une barre de défilement horizontale (“options = list(scrollX = TRUE)”): codebook_ESS9_DT &lt;- datatable(codebook_ESS9) Vous pouvez afficher ce codebook de la manière suivante: codebook_ESS9_DT Vous pouvez chercher des termes et des expressions dans le champ “Search”. Si vous y cherchez “country” (pays), on vous affichera les variables où ce terme apparaît: vous verrez apparaître la variable “cntry” reprend les pays. Quels pays sont représentés dans cette base de données? Pour répondre à cette question, il faut sélectionner la variable “cntry” et l’analyser. Mais comment sélectionne-t-on une variable? Dans le R de base, l’on utilise le signe dollar ($) que l’on appose au nom de la base de données. Cela extrait cette variable en tant que vecteur. Concrètement, cela se fait ainsi: ESS9$cntry ## &lt;labelled&lt;character&gt;[49519]&gt;: Country ## [1] AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT ## [47] AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT ## [93] AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT ## [139] AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT ## [185] AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT ## [231] AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT ## [277] AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT ## [323] AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT ## [369] AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT ## [415] AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT ## [461] AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT ## [507] AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT ## [553] AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT ## [599] AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT ## [645] AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT ## [691] AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT ## [737] AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT ## [783] AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT ## [829] AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT ## [875] AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT ## [921] AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT ## [967] AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT AT ## [ reached getOption(&quot;max.print&quot;) -- omitted 48519 entries ] ## ## Labels: ## value label ## AT Austria ## BE Belgium ## BG Bulgaria ## CH Switzerland ## CY Cyprus ## CZ Czechia ## DE Germany ## DK Denmark ## EE Estonia ## ES Spain ## FI Finland ## FR France ## GB United Kingdom ## HR Croatia ## HU Hungary ## IE Ireland ## IS Iceland ## IT Italy ## LT Lithuania ## LV Latvia ## ME Montenegro ## NL Netherlands ## NO Norway ## PL Poland ## PT Portugal ## RS Serbia ## SE Sweden ## SI Slovenia ## SK Slovakia Pour savoir quels pays sont dans la base de données, l’on peut utiliser la fonction table(), qui résume les données sous forme de tableau: table(ESS9$cntry) ## ## AT BE BG CH CY CZ DE DK EE ES FI FR GB HR HU IE IS IT LT LV ME NL NO PL PT RS SE SI SK ## 2499 1767 2198 1542 781 2398 2358 1572 1904 1668 1755 2010 2204 1810 1661 2216 861 2745 1835 918 1200 1673 1406 1500 1055 2043 1539 1318 1083 Si vous voulez cependant obtenir un tableau plus lisible avec un diagramme en barre, vous pouvez utiliser la fonction freq() du package descr: freq(ESS9$cntry) Cela donne le tableau très pratique suivant: ## Country ## Frequency Percent ## AT 2499 5.047 ## BE 1767 3.568 ## BG 2198 4.439 ## CH 1542 3.114 ## CY 781 1.577 ## CZ 2398 4.843 ## DE 2358 4.762 ## DK 1572 3.175 ## EE 1904 3.845 ## ES 1668 3.368 ## FI 1755 3.544 ## FR 2010 4.059 ## GB 2204 4.451 ## HR 1810 3.655 ## HU 1661 3.354 ## IE 2216 4.475 ## IS 861 1.739 ## IT 2745 5.543 ## LT 1835 3.706 ## LV 918 1.854 ## ME 1200 2.423 ## NL 1673 3.379 ## NO 1406 2.839 ## PL 1500 3.029 ## PT 1055 2.130 ## RS 2043 4.126 ## SE 1539 3.108 ## SI 1318 2.662 ## SK 1083 2.187 ## Total 49519 100.000 On voit qu’il y a un certain nombre de pays, dont la Belgique, avec \\(1767\\) observations. Mais combien de pays y a-t-il exactement? R peut calculer cela pour vous. R comprend la fonction unique() qui vous retourne les valeurs uniques sous forme de vecteur: unique(ESS9$cntry) ## &lt;labelled&lt;character&gt;[29]&gt;: Country ## [1] AT BE BG CH CY CZ DE DK EE ES FI FR GB HR HU IE IS IT LT LV ME NL NO PL PT RS SE SI SK ## ## Labels: ## value label ## AT Austria ## BE Belgium ## BG Bulgaria ## CH Switzerland ## CY Cyprus ## CZ Czechia ## DE Germany ## DK Denmark ## EE Estonia ## ES Spain ## FI Finland ## FR France ## GB United Kingdom ## HR Croatia ## HU Hungary ## IE Ireland ## IS Iceland ## IT Italy ## LT Lithuania ## LV Latvia ## ME Montenegro ## NL Netherlands ## NO Norway ## PL Poland ## PT Portugal ## RS Serbia ## SE Sweden ## SI Slovenia ## SK Slovakia Cela vous donne la liste des pays (ou plutôt des valeurs uniques) sous forme d’un nouveau vecteur. Cependant, cela ne vous informe pas sur leur nombre exact. Vous pouvez obtenir ce nombre par la fonction length() qui compte le nombre d’éléments dans un vecteur. Vous pouvez l’appliquer soit en imbriquant les deux fonctions ainsi: length(unique(ESS9$cntry)) Vous pouvez aussi procéder en deux étapes en créant d’abord l’objet pays_uniques, reprenant la liste des pays sous forme de vecteur: pays_uniques&lt;-unique(ESS9$cntry) pays_uniques ## &lt;labelled&lt;character&gt;[29]&gt;: Country ## [1] AT BE BG CH CY CZ DE DK EE ES FI FR GB HR HU IE IS IT LT LV ME NL NO PL PT RS SE SI SK ## ## Labels: ## value label ## AT Austria ## BE Belgium ## BG Bulgaria ## CH Switzerland ## CY Cyprus ## CZ Czechia ## DE Germany ## DK Denmark ## EE Estonia ## ES Spain ## FI Finland ## FR France ## GB United Kingdom ## HR Croatia ## HU Hungary ## IE Ireland ## IS Iceland ## IT Italy ## LT Lithuania ## LV Latvia ## ME Montenegro ## NL Netherlands ## NO Norway ## PL Poland ## PT Portugal ## RS Serbia ## SE Sweden ## SI Slovenia ## SK Slovakia Puis, vous appliquez la fonction length() à l’objet pays_uniques. Cela vous donnera le nombre d’objets dans le vecteur pays_uniques, c’est-à-dire le nombre de pays dans la base de données ESS9: length(pays_uniques) ## [1] 29 Cela nous indique, qu’il y a 29 pays dans la base de données ESS9. Attention cependant: la fonction length() s’applique aux vecteurs ou listes, mais pas aux bases de données (data.frame ou tibble) ou matrices (matrix). Si nous voulions connaître le nombre d’observations dans la base de données ESS9, nous n’appliquons pas la fonction length(), mais la fonction nrow(), retournant le nombre de lignes (rows) dans la base de données, ce qui revient à nous indiquer le nombre d’observations dans la base de données (vu que chaque ligne correspond à une observation): nrow(ESS9) ## [1] 49519 Nous avons donc \\(49519\\) observations dans cette base de données. Mais comme nous l’avons expliqué, nous ne souhaitons pas analyser tous les pays, mais uniquement la Belgique. Pour continuer nos analyses, il faudra donc filtrer la base de données. 3.3 Filtrer les données Vu que nous voulons analyser les salaires en Belgique, il faut sélectionner uniquement les observations belges. Pour sélectionner uniquement les observations belges, il faut vérifier quelle valeur dans la variable cntry (Country) de la base de données ESS9 (ESS9$cntry ) correspond à la Belgique. Nous pouvons faire cela en utilisant la fonction val_labels du package labelled: val_labels(ESS9$cntry) ## Austria Belgium Bulgaria Switzerland Cyprus Czechia Germany Denmark Estonia ## &quot;AT&quot; &quot;BE&quot; &quot;BG&quot; &quot;CH&quot; &quot;CY&quot; &quot;CZ&quot; &quot;DE&quot; &quot;DK&quot; &quot;EE&quot; ## Spain Finland France United Kingdom Croatia Hungary Ireland Iceland Italy ## &quot;ES&quot; &quot;FI&quot; &quot;FR&quot; &quot;GB&quot; &quot;HR&quot; &quot;HU&quot; &quot;IE&quot; &quot;IS&quot; &quot;IT&quot; ## Lithuania Latvia Montenegro Netherlands Norway Poland Portugal Serbia Sweden ## &quot;LT&quot; &quot;LV&quot; &quot;ME&quot; &quot;NL&quot; &quot;NO&quot; &quot;PL&quot; &quot;PT&quot; &quot;RS&quot; &quot;SE&quot; ## Slovenia Slovakia ## &quot;SI&quot; &quot;SK&quot; Nous voyons que “BE” correspond à la Belgique (Belgium). Il faut donc garder uniquement les observations dont la variable cntry (country) est égale à “BE”. Il y a la fonction de base de R qui s’appelle subset() qui permet de filtrer les observations sur un ou plusieurs critères. Nous allons cependant utiliser la fonction filter() du package dplyr20, faisant partie du tidyverse, car celle-ci est facilement combinable avec d’autres manipulations. Pour sélectionner uniquement les observations dont la variable cntry est égale à “BE”, il faut utiliser la fonction filter() de la manière suivante: ESS9_BE&lt;-filter(ESS9,cntry==&quot;BE&quot;) On crée l’objet ESS9_BE contenant la base de données avec uniquement les cas belges. Comme vous le voyez, le premier argument de cette fonction filter() est la base de données ESS9. Puis, séparé par une virgule, le second argument est la condition à respecter. Ici, la condition est que la variable (colonne) cntry doit être égale à “BE”. En lisant ce code, vous aurez certainement remarqué deux choses: La première est que “BE” est noté entre guillemets. En effet, lorsque vous filtrez des chaînes de caractère (string/character), il faut utiliser des guillemets autour des caractères que l’on souhaite filtrer. Si on n’utilise pas de guillemets, R pense qu’on lui indique un objet de nom BE. Ne connaissant pas cet objet, R vous retournera une erreur. Entre guillemets, R sait que l’on veut dire la chaîne de caractère “BE”. Si, en revanche, vous vouliez filtrer un nombre (par exemple: \\(1\\), \\(1000\\) ou \\(1.35\\)), vous n’avez pas besoin d’ajouter de guillemets (concrètement: vous ne devez pas en mettre). la deuxième est que l’on a indiqué un double égal (“==”). En effet, si l’on indique que l’on voudrait filtrer des éléments correspondant à ce qu’on indique (ici “BE”), il faut indiquer un double égal (“==”). R connaît ainsi un certain nombre d’opérateurs logiques: \\(==\\) : est égal à \\(!=\\) : est différent de \\(!x\\) : n’est pas x \\(%in%\\) : est un des éléments dans la liste \\(&lt;\\) : est plus petit que \\(&lt;=\\) : est plus petit ou égal à \\(&gt;\\) : est plus grand que \\(&gt;=\\) : est plus grand ou égal à \\(x \\&amp; y\\) : condition x ET condition y \\(x | y\\) : condition x OU condition y Prenons des exemples pour les deux derniers opérateurs de la liste “&amp;” et “|” : Imaginons que vous vouliez garder les observations en Belgique, mais uniquement si elles sont des femmes: dans ce cas si vous utilisiez le lien logique “&amp;” ente les conditions. Cela signifierait que les deux conditions doivent être remplies simultanément. Les observations sélectionnées doivent être en Belgique ET des femmes. Les observations en Belgique qui ne sont pas des femmes ou les femmes qui ne sont pas en Belgique ne seront pas sélectionnées. Le code serait alors: ESS9_BE_Women&lt;-filter(ESS9,cntry==&quot;BE&quot; &amp; gndr==2) #Regardez le résultat: freq(ESS9_BE_Women$cntry) ## Country ## Frequency Percent ## BE 899 100 ## Total 899 100 freq(ESS9_BE_Women$gndr) ## Gender ## Frequency Percent ## 2 899 100 ## Total 899 100 Imaginons que vous vouliez garder toutes les observations en Belgique et toutes les femmes: dans ce cas, vous devriez séparer les deux conditions par le symbole “|”. Les observations sélectionnées doivent être en Belgique OU des femmes. Toutes les observations belges sont alors sélectionnées et toutes les observations “femmes”. Les observations en Belgique qui ne sont pas des femmes seront sélectionnées tout comme les femmes qui ne sont pas en Belgique. Le code serait alors: ESS9_BE_OR_Women&lt;-filter(ESS9,cntry==&quot;BE&quot; | gndr==2) #Regardez le résultat: freq(ESS9_BE_OR_Women$cntry) ## Country ## Frequency Percent ## AT 1346 4.918 ## BE 1767 6.457 ## BG 1222 4.465 ## CH 767 2.803 ## CY 415 1.516 ## CZ 1349 4.929 ## DE 1146 4.188 ## DK 726 2.653 ## EE 1067 3.899 ## ES 821 3.000 ## FI 907 3.314 ## FR 1097 4.008 ## GB 1206 4.407 ## HR 1082 3.954 ## HU 955 3.490 ## IE 1161 4.242 ## IS 440 1.608 ## IT 1447 5.287 ## LT 1261 4.608 ## LV 621 2.269 ## ME 592 2.163 ## NL 840 3.069 ## NO 629 2.298 ## PL 790 2.887 ## PT 610 2.229 ## RS 1058 3.866 ## SE 757 2.766 ## SI 708 2.587 ## SK 580 2.119 ## Total 27367 100.000 freq(ESS9_BE_OR_Women$gndr) ## Gender ## Frequency Percent ## 1 868 3.172 ## 2 26499 96.828 ## Total 27367 100.000 Une fois que nous avons exécuté la fonction filter() pour garder uniquement les observations en Belgique créant la base de données nommée ESS9_BE, nous allons vérifier qu’elle contient plus que des observations belges avec la fonction table() et freq(): ESS9_BE&lt;-filter(ESS9,cntry==&quot;BE&quot;) table(ESS9_BE$cntry) # Attention à bien sélectionner la base de données ESS9_BE ## ## BE ## 1767 freq(ESS9_BE$cntry) # Attention à bien sélectionner la base de données ESS9_BE ## Country ## Frequency Percent ## BE 1767 100 ## Total 1767 100 Comme nous le voyons, le filtrage a fonctionné: il n’y plus que \\(1767\\) observations belges. Nous pouvons donc procéder à une analyse descriptive des salaires en Belgique dans le chapitre suivant. Si vous suivez un enseignement de Lev Lhommeau, il est probable que l’on vous mette le fichier à disposition↩︎ La fonction subset() s’utilise de manière similaire à la fonction filter(). Vous pouvez donc l’utiliser de manière analogue à la fonction filter() présentée ici.↩︎ "],["salaire_belge_stat_desc.html", "Chapitre 4 Le salaire de Belges 4.1 Statistiques descriptives et simples graphiques des salaires des Belges 4.2 Comparer une distribution à une distribution normale 4.3 Distribution normale et transformation logarithmique 4.4 Distribution normale et probabilités 4.5 Connaître la probabilité des salaires", " Chapitre 4 Le salaire de Belges Si vous avez fermé R depuis le dernier chapitre, il faudra lancer les packages. Vous pouvez le faire avec le code suivant: if (!require(&quot;pacman&quot;)) install.packages(&quot;pacman&quot;) #Cela vérifie #si le package pacman est installé. #S&#39;il ne l&#39;est pas, il est installé. pacman::p_load(tidyverse, descr, rcompanion, codebook, DT, sjPlot, labelled) #On lance les packages 4.1 Statistiques descriptives et simples graphiques des salaires des Belges Si l’on veut étudier les salaires des Belges il faut que nous continuions à travailler avec la base de données ESS9_BE que nous avons créée dans le chapitre précédent précédemment qui contient exclusivement les observations belges. Par ailleurs, il faut que nous identifiions la variable de la base de données contenant les salaires. Il s’agit de la variable grspnum. Nous pouvons obtenir des statistiques descriptives de cette variable avec la commande summary(): summary(ESS9_BE$grspnum) ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## 0 2019 2800 3148 3700 40000 1068 On voit que la valeur minimale est de \\(0€\\), la valeur maximale de \\(40000€\\). La moyenne s’élève à \\(3148€\\) tandis que la médiane est sensiblement plus basse à \\(2800€\\). Cela suggère qu’un nombre restreint de valeurs très élevées tirent la moyenne vers le haut. Il est à noter qu’il y a un nombre important de valeurs manquantes: \\(1068\\), soit \\(60\\%\\) sur les \\(1767\\). Faisons-nous une image de cette distribution. Vu qu’il s’agit d’une variable continue, nous représentons ceci sous forme d’histogramme avec la fonction de base hist() et la fonction un peu plus avancée plotNormalHistogram du package rcompanion y ajoutant une courbe de distribution normale (“cloche”)21: hist(ESS9_BE$grspnum, breaks = 50) plotNormalHistogram(ESS9_BE$grspnum, breaks = 50) On peut aussi faire de graphiques plus attrayants avec les fonctions du package ggplot2 de l’ensemble tidyverse22: ggplot(ESS9_BE, aes(x=grspnum)) + geom_histogram(bins=50) On voit très clairement que la plupart des valeurs sont concentrées entre \\(0€\\) et \\(5000€\\) et qu’au-delà de \\(10000\\) il n’y a plus que quelques observations isolées. Celles-ci tirent la moyenne vers le haut. Un autre moyen de représenter cela est de le faire à l’aide d’une “boîte à moustache” (boxplot): boxplot(ESS9_BE$grspnum) Vous pouvez aussi la représenter à l’aide de du package ggplot223: ggplot(ESS9_BE, aes(x=grspnum)) + geom_boxplot() Les boxplots indiquent aussi très clairement qu’il y a quelques valeurs “extrêmes”, très élevées, qui “tirent” la moyenne vers le haut. Par ailleurs, il y a un certain nombre d’observations avec des revenus très faibles, tels que \\(0€\\). Il nous semble utile de considérer seulement les personnes travaillant à temps plein. Par ailleurs, il faut contrôler que les données soient cohérentes. La Belgique ayant un salaire minimum, il n’est pas légalement possible pour un salarié de percevoir un salaire de moins de \\(1000€\\) tout en travaillant à temps plein24. Nous nous concentrons ainsi sur les Belges travaillant plus de 34 heures pas semaine (temps plein) et gagnant plus de \\(1000€\\) par mois, mais moins de \\(15000€\\) par mois. La variable “wkhtot” indique le nombre d’heures travaillées par semaine. On utilise la fonction filter() pour sélectionner les observations. On crée une nouvelle base de données nommée ESS9_BE_fulltime: ESS9_BE_fulltime&lt;-filter(ESS9_BE, #Base de donnés wkhtot&gt;34 &amp; # Travaillant plus de 34 heures grspnum&gt;1000 &amp; # Percevant plus de 1000€, grspnum&lt;15000) # mais moins de 15.000€. Vous pouvez vérifier cette base de données, notamment en vous assurant qu’il n’y a personne qui ravitaille moins de 35 heures et percevant moins de \\(1000€\\) et plus de \\(15000€\\). Vous pouvez utiliser la fonction summary() pour vérifier que les variables grspnum et wkhtot dans la base de données ESS9_BE_fulltime ne contiennent plus que des valeurs compatibles avec le filtre que l’on vient d’appliquer: summary(ESS9_BE_fulltime$grspnum) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1200 2400 2986 3365 4000 14000 summary(ESS9_BE_fulltime$wkhtot) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 35.00 38.00 40.00 45.58 46.00 168.00 Le filtrage a fonctionné: dans notre échantillon, personne ne travaille moins de 35 heures et personne ne perçoit moins de \\(1000€\\) (le minimum est de \\(1200€\\)) et plus de \\(15000€\\) (le maximum est \\(14000€\\)). Cependant, des anomalies apparaissent au niveau du temps de travail. L’on peut s’en rendre compte avec les fonctions table() et freq(): table(ESS9_BE_fulltime$wkhtot) ## ## 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 52 53 55 56 60 62 65 70 72 75 80 84 100 105 147 168 ## 19 12 13 110 18 103 9 23 9 8 67 4 3 7 1 48 1 1 8 1 24 1 6 13 2 4 3 1 1 1 1 4 freq(ESS9_BE_fulltime$wkhtot) ## Total hours normally worked per week in main job overtime included ## Frequency Percent ## 35 19 3.6122 ## 36 12 2.2814 ## 37 13 2.4715 ## 38 110 20.9125 ## 39 18 3.4221 ## 40 103 19.5817 ## 41 9 1.7110 ## 42 23 4.3726 ## 43 9 1.7110 ## 44 8 1.5209 ## 45 67 12.7376 ## 46 4 0.7605 ## 47 3 0.5703 ## 48 7 1.3308 ## 49 1 0.1901 ## 50 48 9.1255 ## 52 1 0.1901 ## 53 1 0.1901 ## 55 8 1.5209 ## 56 1 0.1901 ## 60 24 4.5627 ## 62 1 0.1901 ## 65 6 1.1407 ## 70 13 2.4715 ## 72 2 0.3802 ## 75 4 0.7605 ## 80 3 0.5703 ## 84 1 0.1901 ## 100 1 0.1901 ## 105 1 0.1901 ## 147 1 0.1901 ## 168 4 0.7605 ## Total 526 100.0000 Ainsi 4 répondants affirment travailler \\(168\\) heures par semaine. Vu qu’une semaine compte \\(168\\) heures et que l’être humain a un besoin physiologique de sommeil, ces réponses semblent aberrantes25. Vue que l’analyse que nous voulons mener ne porte pas sur le temps de travail, nous n’allons ni investiguer ces cas plus en détail, ni les exclure de nos analyses. La distribution de la variable dans la base de données que nous avons filtrée, se rapproche-t-elle d’une distribution normale? Analysons cela à nouveau avec les histogrammes et “boxplots”: #Avec R de base: hist(ESS9_BE_fulltime$grspnum, breaks = 50, main=&quot;Histogramme: Salaire des Belges en 2018&quot;, xlab=&quot;Salaire des Belges en €&quot;) #Avec ggplot2: ESS9_BE_fulltime %&gt;% ggplot(aes(x=grspnum)) + geom_histogram(bins = 50)+ ggtitle(&quot;Histogramme: Salaire des Belges en 2018&quot;) + xlab(&quot;Salaire des Belges en €&quot;) Avec des boxplot, la variable grspnum donne le résultat suivant: #Avec R de base: boxplot(ESS9_BE_fulltime$grspnum, ylab = &quot;Salaire des Belges en €&quot;, main = &quot;Boîte à moustache: Salaire des Belges en 2018&quot;) #Avec ggplot2: ESS9_BE_fulltime %&gt;% ggplot(aes(x=grspnum)) + geom_boxplot() + ggtitle(&quot;Boîte à moustache: Salaire des Belges en 2018&quot;)+ xlab(&quot;Boîte à moustache: Salaire des Belges en 2018&quot;) L’histogramme et la boîte à moustache montrent une distribution moins “écrasée”. Elle reste cependant asymétrique avec des valeurs très élevées – et une “coupure” vers le bas à \\(1200€\\). La distribution semble donc toujours loin d’être normale. 4.2 Comparer une distribution à une distribution normale Visuellement, la distribution de la variable des salaires (grspnum) ne semble pas normale. Essayons d’objectiver cela. Nous rappelons quelques caractéristiques d’une distribution normale: la distribution est symétrique; moyenne \\(=\\) médiane \\(=\\) mode; \\(\\approx68\\%\\) des observations se trouvent dans l’intervalle entre \\(-1\\) écart type (\\(\\sigma\\)) et \\(+1\\) écart type (\\(\\sigma\\)) de la moyenne (\\(\\mu\\)): \\([\\mu-\\sigma;\\mu+\\sigma]\\) \\(\\approx95\\%\\) des observations se trouvent dans l’intervalle entre \\(-1,96\\) écart type (\\(\\sigma\\)) et \\(+1,96\\) écart type (\\(\\sigma\\)) de la moyenne (\\(\\mu\\)): \\([\\mu-1,96\\sigma;\\mu+1,96\\sigma]\\) \\(\\approx95,5\\%\\) des observations se trouvent dans l’intervalle entre \\(-2\\) écart type (\\(\\sigma\\)) et \\(+2\\) écart type (\\(\\sigma\\)) de la moyenne (\\(\\mu\\)): \\([\\mu-2\\sigma;\\mu+2\\sigma]\\) \\(\\approx2,5\\%\\) des observation sont supérieures à \\(1,96\\) écart type (\\(\\sigma\\)) de la moyenne (\\(\\mu\\)): \\([\\mu+1,96\\sigma;+\\infty)\\) \\(\\approx2,5\\%\\) des observation inférieurs à \\(-1,96\\) écart type (\\(\\sigma\\)) de la moyenne (\\(\\mu\\)): \\([\\mu-1,96\\sigma;-\\infty)\\) La fonction nonantecinq() que nous définissions permet de comparer la distribution d’une variable avec les caractéristiques d’une distribution normale. Pour définir une nouvelle fonction, il faut utiliser la fonction fonction()26: nonantecinq&lt;-function(x){ #On exclut les valeurs manquantes de la variable analysée x1&lt;-x[is.na(x)!=T] #On calcule l&#39;effectif total x1_l1&lt;-length(x[is.na(x)!=T]) #On calcule l&#39;effectif se situant à -1,96 écart types de la moyenne x1_low&lt;-length(x1[x1 &lt; mean(x1, na.rm=T)-1.96*sd(x1, na.rm=T)]) #On calcule l&#39;effectif se situant à +1,96 écart types de la moyenne x1_high&lt;-length(x1[x1 &gt; mean(x1, na.rm=T)+1.96*sd(x1, na.rm=T)]) #On calcule l&#39;effectif se situant à -1 écarts types de la moyenne (point d&#39;inflexion si normal) x1_low_inflex&lt;-length(x1[x1 &lt; mean(x1, na.rm=T)-sd(x1, na.rm=T)]) #On calcule l&#39;effectif se situant à +1 écart types de la moyenne (point d&#39;inflexion si normal) x1_high_inflex&lt;-length(x1[x1 &gt; mean(x1, na.rm=T)+sd(x1, na.rm=T)]) #Pourcentages: pourcent_bas&lt;-x1_low/x1_l1 pourcent_haut&lt;-x1_high/x1_l1 pourcent_1.96&lt;-(1-(pourcent_bas+pourcent_haut))*100 pourcent_inflex_bas&lt;-x1_low_inflex/x1_l1 pourcent_inflex_haut&lt;-x1_high_inflex/x1_l1 pourcent_1_inflex&lt;-(1- (pourcent_inflex_bas + pourcent_inflex_haut))*100 #Mode(s) mode_func &lt;- function(x_1) { modes_multi&lt;-which(table(x_1)==max(table(x_1))) mode_final&lt;-as.numeric(names(modes_multi)) return(mode_final) } mode_calc&lt;-mode_func(x) #Affichage des résultats message(paste(&quot; Moyenne=&quot;,round(mean(x1, na.rm=T),2),&quot;\\n&quot;, &quot;Écart type=&quot;,round(sd(x1, na.rm=T),2),&quot;\\n&quot;, &quot;Médiane=&quot;,round(median(x1, na.rm=T),2),&quot;\\n&quot;, &quot;Mode (si multiples, le plus faible)=&quot;,ifelse(length(mode_calc)&gt;1, round(mode_calc[1],2), round(mode_calc,2)),&quot;\\n&quot;, &quot;Le point d&#39;inflexion (si la distribution est normale) à -1 écart type prend la valeur:&quot;, round(mean(x1, na.rm=T)-sd(x1, na.rm=T),2),&quot;\\n&quot;, &quot;Le point d&#39;inflexion (si la distribution est normale) à +1 écart type prend la valeur:&quot;, round(mean(x1, na.rm=T)+sd(x1, na.rm=T),2),&quot;\\n&quot;, round(pourcent_1_inflex,2),&quot;%&quot;,&quot; des valeurs se situent entre -1 et +1 écart types de la moyenne.&quot;, &quot;\\n&quot;, round(pourcent_inflex_bas*100,2),&quot;%&quot;,&quot; des valeurs se situent en dessous de -1 écart types de la moyenne.&quot;,&quot;\\n&quot;, round(pourcent_inflex_haut*100,2),&quot;%&quot;,&quot; des valeurs se situent au-dessus de 1 écart types de la moyenne.&quot;,&quot;\\n&quot;, &quot;-1,96 écarts types prend la valeur:&quot;, round(mean(x1, na.rm=T)-1.96*sd(x1, na.rm=T),2), &quot;\\n&quot;, &quot;+1,96 écarts types prend la valeur:&quot;, round(mean(x1, na.rm=T)+1.96*sd(x1, na.rm=T),2), &quot;\\n&quot;, round(pourcent_1.96,2),&quot;%&quot;, &quot; des valeurs se situent entre -1,96 et +1,96 écart types de la moyenne.&quot;, &quot;\\n&quot;, round(pourcent_bas*100,2),&quot;%&quot;,&quot; des valeurs se situent en dessous de -1,96 écart types de la moyenne.&quot;,&quot;\\n&quot;, round(pourcent_haut*100,2),&quot;%&quot;, &quot; des valeurs se situent au-dessus de 1,96 écart types de la moyenne.&quot;) ) } Une fois que vous avez exécuté le code ci-dessus, la fonction nonantecinq() apparaîtra dans l’environnement global de R. Si vous fermer R et que vous n’enregistrez pas cet environnement global, vous devrez récréer la fonction nonantecinq() avec le code ci-dessus. Lorsque la fonction nonantecinq() est définie, vous pouvez la lancer comme toutes les fonctions de R de base ou des packages. Vous indiquez simplement le nom de la fonction avec les parenthèses dans lesquelles vous ajoutez, le cas échéant le ou les arguments. La fonction nonantecinq() ne prend qu’un seul argument qui doit être un vecteur numérique (une variable contenant des nombres). Ici, nous voulons vérifier le salaire des Belges (grspnum): nonantecinq(ESS9_BE_fulltime$grspnum) ## Moyenne= 3365.44 ## Écart type= 1673.51 ## Médiane= 2986 ## Mode (si multiples, le plus faible)= 3000 ## Le point d&#39;inflexion (si la distribution est normale) à -1 écart type prend la valeur: 1691.93 ## Le point d&#39;inflexion (si la distribution est normale) à +1 écart type prend la valeur: 5038.96 ## 85.36 % des valeurs se situent entre -1 et +1 écart types de la moyenne. ## 5.51 % des valeurs se situent en dessous de -1 écart types de la moyenne. ## 9.13 % des valeurs se situent au-dessus de 1 écart types de la moyenne. ## -1,96 écarts types prend la valeur: 85.35 ## +1,96 écarts types prend la valeur: 6645.53 ## 96.39 % des valeurs se situent entre -1,96 et +1,96 écart types de la moyenne. ## 0 % des valeurs se situent en dessous de -1,96 écart types de la moyenne. ## 3.61 % des valeurs se situent au-dessus de 1,96 écart types de la moyenne. On voit donc également de manière “objective” que la variable salaire (grspnum) n’est absolument pas normale: La distribution n’est pas symétrique: \\(5,51\\%\\) des valeurs se situent en dessous de -1 écart types de la moyenne, tandis que \\(9,13\\%\\) des valeurs se situent au-dessus de 1 écart types de la moyenne. La moyenne, la médiane et le mode sont différents. En particulier, la moyenne est plus élevée que le mode et la médiane. \\(\\approx85\\%\\) des observations se trouvent entre -1 et +1 écart type (contre \\(68\\%\\) pour une distribution normale) \\(0\\%\\) des observations se trouvent en dessous de \\(1,96\\) écart types (contre \\(2,5\\%\\) pour une distribution normale) \\(3,6\\%\\) des observations se trouvent au-dessus de \\(1,96\\) écart types (contre \\(2,5\\%\\) pour une distribution normale) 4.3 Distribution normale et transformation logarithmique La distribution de la variable des salaires (grspnum) est très éloignée d’une distribution normale. Quelques observations très élevées “tirent” la moyenne vers le haut. Cela est habituel pour les variables de type salaire ou patrimoine. Cependant, l’on peut souvent transformer ces variables de manière à les rapprocher d’une distribution normale. Une transformation très usitée pour cela est la transformation logarithmique (on prend souvent le logarithme népérien). Cela a pour effet de davantage espacer les valeurs faibles tout en réduisant les espaces entre les valeurs élevées. Nous vous illustrons cela graphiquement à l’aide une suite \\(B\\) allant de \\(1\\) à \\(1000\\): suite_B&lt;-1:1000 # Créons vecteur de 1 à 1000 log_suite_B&lt;-log(suite_B) # Vecteur du logarithme de la suite B suite_B_matrix&lt;-cbind(suite_B,log_suite_B) # Nous créons une matrice avec les deux vecteurs suite_B_df&lt;-as.data.frame(suite_B_matrix) # Nous la transformons en base de données (dataframe) suite_B_df %&gt;% # nous utilisions une &quot;pipe&quot; ggplot(aes(x=suite_B,y=log_suite_B)) + geom_line() + xlab(&quot;Suite B&quot;) + ylab(&quot;Logarithme népérien de la suite B&quot;) + ggtitle(&quot;ggplot2: Suite B et transformation logarithmique&quot;) plot(suite_B_df$suite_B, suite_B_df$log_suite_B, type = &quot;l&quot;, main=&quot;Base R: Suite B et transformation logarithmique&quot;, xlab = &quot;Suite B&quot;, ylab=&quot;Logarithme népérien de la suite B&quot;) En abscisse, l’on voit la suite \\(B\\) (l’objet suite_B) allant de 1 à 1000. En ordonné, nous avons cette même suite \\(B\\) transformée de manière logarithmique. L’on voit, très clairement que la courbe augmente fortement lors de faibles valeurs puis s’aplanit. Cela correspond à l’augmentation de l’espacement des valeurs faibles et au rapprochement des grandes valeurs. Nous allons donc appliquer cette transformation à la variable grspnum reprenant les salaires. Pour effectuer cette transformation, nous utilisons la fonction mutate() du package dplyr: celle-ci permet de créer de nouvelles variables dans une base de données. Cette fonction s’utilise de la manière suivante: vous indiquez comme premier argument, la base de donnés dans laquelle vous souhaitez ajouter une variable. Le deuxième argument correspond au nom de cette nouvelle variable suivie du signe \\(=\\) et de la/des valeur(s) que doit prendre cette nouvelle variable. L’on peut ainsi indiquer que cette nouvelle variable doit correspondre au logarithme népérien de la variable grspnum. Le logarithme népérien se calcule avec la fonction log(): ESS9_BE_fulltime &lt;- mutate(ESS9_BE_fulltime,log_grspnum=log(grspnum)) Regardons, dans quelle mesure la distribution a changée et si l’on s’est rapproché d’une distribution normale. Vérifions à l’aide d’un histogramme et d’un boxplot : #Avec R de base: hist(ESS9_BE_fulltime$log_grspnum, breaks = 30, xlab = &quot;Logarithme du salaire des Belges&quot;, # Libellé de l&#39;abscisse. main = &quot;Histogramme: Logarithme du salaire des Belges en 2018&quot;) # Titre du graphique #Avec ggplot2: ESS9_BE_fulltime %&gt;% ggplot(aes(x=log_grspnum)) + geom_histogram(bins = 30) + ggtitle(&quot;Histogramme: Logarithme du salaire des Belges en 2018&quot;) + xlab(&quot;Logarithme du salaire des Belges&quot;) #Avec R de base: boxplot(ESS9_BE_fulltime$log_grspnum, xlab = &quot;Logarithme du salaire des Belges&quot;, # Libellé de l&#39;abscisse. main = &quot;Histogramme: Logarithme du salaire des Belges en 2018&quot;) # Titre du graphique #Avec ggplot2: ESS9_BE_fulltime %&gt;% ggplot(aes(x=log_grspnum)) + geom_boxplot() + ggtitle(&quot;Boxplot: Logarithme du salaire des Belges en 2018&quot;) + xlab(&quot;Logarithme du salaire des Belges&quot;) La distribution est sensiblement moins étirée. Cela ressemble plus à une distribution normale. Comparons l’histogramme avec une courbe de densité d’une distribution normale: #Avec R de base: plotNormalHistogram(ESS9_BE_fulltime$log_grspnum, breaks = 30, xlab = &quot;Logarithme du salaire des Belges&quot;, # Libellé de l&#39;abscisse. main = &quot;Histogramme: Logarithme du salaire des Belges en 2018&quot;) # Titre du graphique #Avec ggplot2: ESS9_BE_fulltime %&gt;% ggplot(aes(x=log_grspnum)) + geom_histogram(aes(y =..density..), bins = 30) + stat_function(fun = dnorm, args = list(mean = mean(ESS9_BE_fulltime$log_grspnum), sd = sd(ESS9_BE_fulltime$log_grspnum)), col=&quot;blue&quot;, size=1.25) + ggtitle(&quot;Histogramme: Logarithme du salaire des Belges en 2018&quot;) + xlab(&quot;Logarithme du salaire des Belges&quot;) Vérifions cela à l’aide de la fonction nonantecinq: nonantecinq(ESS9_BE_fulltime$log_grspnum) ## Moyenne= 8.03 ## Écart type= 0.42 ## Médiane= 8 ## Mode (si multiples, le plus faible)= 8.01 ## Le point d&#39;inflexion (si la distribution est normale) à -1 écart type prend la valeur: 7.61 ## Le point d&#39;inflexion (si la distribution est normale) à +1 écart type prend la valeur: 8.44 ## 67.3 % des valeurs se situent entre -1 et +1 écart types de la moyenne. ## 15.78 % des valeurs se situent en dessous de -1 écart types de la moyenne. ## 16.92 % des valeurs se situent au-dessus de 1 écart types de la moyenne. ## -1,96 écarts types prend la valeur: 7.21 ## +1,96 écarts types prend la valeur: 8.84 ## 94.68 % des valeurs se situent entre -1,96 et +1,96 écart types de la moyenne. ## 1.71 % des valeurs se situent en dessous de -1,96 écart types de la moyenne. ## 3.61 % des valeurs se situent au-dessus de 1,96 écart types de la moyenne. Les données numériques sont tout autant instructives que le diagnostic visuel: Le mode, la médiane et la moyenne sont tous très proches de \\(8\\) (et donc presque identiques). \\(67\\%\\) des observations se trouvent entre \\(-1\\) et \\(+1\\) écart type (contre \\(\\approx68\\%\\) d’une distribution normale). \\(\\approx95\\%\\) des observations se trouvent entre \\(-1,96\\) et \\(+1,96\\) écart types (comme pour une distribution normale). \\(2\\%\\) des observations se trouvent en dessous de \\(-1,96\\) écart types et \\(4%\\) se trouvent au-dessus de \\(+1,96\\) écart types (contre \\(2,5\\%\\) en dessous et au-dessus dans une distribution normale). Empiriquement, nous ne sommes pas face à une distribution tout à fait normale, mais nous en sommes très proches. Cela d’autant plus que le salaire (grspnum, d’où log_grspnum) est une variable continue, que la réponse est une déclaration spontanée (les sondés auront tendance à donner des chiffres “ronds”)27 et que l’échantillon est assez grand (\\(n=526\\)). Il y a donc une très forte probabilité que la variable sous-jacente dans la population suive une distribution normale. L’on peut donc traiter la variable salaire transformée (log_grspnum) comme une distribution normale. Cela nous permet à calculer des probabilités comme nous allons le voir dans le prochain chapitre. 4.4 Distribution normale et probabilités La distribution normale a un certain nombre de propriétés très intéressantes. L’une d’entre elles et que lorsqu’on connait la moyenne et la variance/l’écart type (ou qu’on l’estime) d’une distribution normale, l’on peut facilement connaître la probabilité d’obtenir une valeur dans un certain intervalle. On se sert de cette propriété dans la statistique inférentielle (qui vise à apporter des connaissances sur la population et pas seulement sur l’échantillon), car les moyennes d’échantillons d’assez grande taille (\\(n&gt;30\\)) tirés d’une même population suivent une loi normale (même si la variable étudiée ne suit pas une distribution normale). Cela permet de calculer des intervalles de confiance et le risque de faux positifs (p-valeur) et de tirer des conclusions sur la population dont est issu l’échantillon28. 4.5 Connaître la probabilité des salaires La variable log_grspnum que l’on a créée dans le chapitre précédent reprend la transformation logarithmique du revenu mensuel des Belges travaillant à temps plein (\\(&gt;34\\) heures de travail), sans des valeurs aberrantes (trop faibles pour un travail à temps plein) et des revenus dépassant les \\(15.000€\\). Cette variable log_grspnum peut être considérée comme suivant une distribution normale. Par conséquent, l’on peut facilement déterminer la probabilité qu’un Belge travaillant à temps plein touche un salaire dans un certain intervalle. On peut, par exemple, déterminer quelle est la probabilité de bénéficier d’un revenu supérieur à \\(3000€\\), inférieur à \\(1000€\\) ou située entre \\(1350€\\) et \\(1400€\\). R permet de calculer cette probabilité de manière très simple à l’aide de la fonction pnorm(). Celle-ci permet de calculer la probabilité qu’une valeur se trouve dans un certain intervalle, en indiquant la valeur dont on veut connaitre la probabilité, la moyenne, l’écart type et si l’on cherche l’intervalle supérieur ou inférieur à la valeur recherchée. R permet, par ailleurs, de représenter graphiquement assez simples ces intervalles. Notre exemple comporte une difficulté supplémentaire, car nous avons transformé le salaire avec le logarithme népérien. En effet, nous ne pouvons pas directement indiquer l’intervalle de revenu dont nous souhaitons connaître la probabilité. Il faut que nous transformions le salaire que nous voulons tester à l’aide du logarithme népérien29. Vu que R permet d’imbriquer des fonctions, l’on peut assez facilement surmonter cette difficulté. Si vous nous voulions connaitre la probabilité de bénéficier d’un revenu supérieur à \\(2500€\\), nous pouvons le faire ainsi: pnorm(log(2500), # Le logarithme népérien de 2500 mean = mean(ESS9_BE_fulltime$log_grspnum), #la moyenne de la variable log_grspnum sd=sd(ESS9_BE_fulltime$log_grspnum),#l&#39;écart type de la variable log_grspnum lower.tail = F #Nous voulons connaitre la probabilité que la valeur soit au-dessus de 2500 ) ## [1] 0.6882183 La probabilité de percevoir un salaire supérieur à \\(2500€\\) est exprimé en probabilité: \\(0,69\\), ce qui correspond à \\(69\\%\\). Si l’on voulait calculer la probabilité de percevoir un salaire inférieur à \\(2500€\\), l’on indiquerait le code suivant:. pnorm(log(2500), # Le logarithme népérien de 2500 mean = mean(ESS9_BE_fulltime$log_grspnum), #la moyenne de la variable log_grspnum sd=sd(ESS9_BE_fulltime$log_grspnum),#l&#39;écart type de la variable log_grspnum lower.tail = T #Nous voulons connaitre la probabilité que la valeur soit en dessous de 2500 ) ## [1] 0.3117817 La probabilité de percevoir un salaire inférieur à \\(2500€\\) est donc de \\(0,31\\) soit \\(31\\%\\). Vous aurez noté que la probabilité cumulé de percevoir un salaire inférieur à \\(2500€\\) et supérieur à \\(2500€\\) est de \\(1\\) (\\(0,69+0,31=1\\)). L’on peut utiliser cela pour calculer la probabilité e percevoir un salaire dans un certain intervalle. Si l’on voulait connaître la probabilité de percevoir un salaire supérieur à \\(2500€\\),mais inférieur à \\(2800€\\), l’on calcule simplement: #La probabilité de bénéficier d&#39;un salaire supérieur à 2500 € proba_sup_2500&lt;-pnorm(log(2500), # Le logarithme népérien de 2500 mean = mean(ESS9_BE_fulltime$log_grspnum), #la moyenne de la variable log_grspnum sd=sd(ESS9_BE_fulltime$log_grspnum),#l&#39;écart type de la variable log_grspnum lower.tail = F #Nous voulons connaitre la probabilité que la valeur soit au dessous de 2500 ) #La probabilité de bénéficier d&#39;un salaire inférieur à 2800 € proba_inf_2800&lt;-pnorm(log(2800), # Le logarithme népérien de 2800 mean = mean(ESS9_BE_fulltime$log_grspnum), #la moyenne de la variable log_grspnum sd=sd(ESS9_BE_fulltime$log_grspnum),#l&#39;écart type de la variable log_grspnum lower.tail = T #Nous voulons connaitre la probabilité que la valeur soit en dessous de 2800 ) #La différence entre la probabilité de bénéficier d&#39;un salaire supérieur à 2500 € et la probabilité de bénéficier d&#39;un salaire inférieur à 2800 € proba_combi_2500_2800&lt;-proba_sup_2500-proba_inf_2800 proba_combi_2500_2800 ## [1] 0.2745332 La probabilité de bénéficier d’un salaire entre \\(2500€\\) et \\(2800€\\) est donc de \\(0,27\\), soit \\(27\\%\\). L’on peut représenter cela de manière visuelle. Par simplicité, nous utilisions le code généré par l’interface graphique “R Commander” (Rcmdr)30. D’autres manière de représenter cela impliquent de combiner, voir d’imbriquer, des fonctions telles que polygon()/geom_polygon(), dnorm() et éventuellement rev() et rep() qui nous semble trop complliqués à expliquer dans ce syllabus. pour utiliser les fonctions issues du package Rcmdr, lancez le ainsi: p_load(Rcmdr) Ensuite, vous pouvez soit faire les manipulations dans “R Commander” ou utiliser le code dans le R Script . Si vous souhaiter utiliser le code dans le R Script, je vous conseille de fermer la fenêtre du “R Commander” pour que les graphiques générés n’apparaissent pas dans la fenêtre du “R Commander” pas à leur emplacment habituel: .x &lt;- seq(6.661, 9.395, length.out=1000) plotDistr(.x, dnorm(.x, mean=mean(ESS9_BE_fulltime$log_grspnum), sd=sd(ESS9_BE_fulltime$log_grspnum)), cdf=FALSE, xlab=&quot;Revneun en log(€)&quot;, ylab=&quot;Densité&quot;, main=paste(&quot;Normal Distribution: Mean=8.027993, Standard deviation=0.4155336&quot;), regions=list(c(log(2500), log(2800))), col=c(&#39;#BEBEBE&#39;, &#39;#BEBEBE&#39;), legend.pos=&#39;topright&#39;) Grâce à ce graphique l’on voit visuellement où se situent les \\(27\\%\\) de probabilité de percevoir entre \\(2500€\\) et \\(2800€\\). Nous définissions qu’il y a 50 barres dans l’histogramme: “breaks = 50” comme second argument de la fonction hist() et plotNormalHistogram.↩︎ Nous définissons qu’il y a 50 barres dans l’histogramme: “bins=50” comme second argument de la fonction geom_histogram.↩︎ Si vous comparer le code du boxplot à l’histogramme avec ggplot2, vous remarquerez, que seule la deuxième partie de la commande a changée. Cette similarité du code est un grand avantage du package ggplot2. Nous reviendrons plus tard sur la syntaxe et l’utilisation de ggplot2.↩︎ Il est certainement possible qu’il y ait des cas très spécifiques où cela puisse se produire. Mais nous excluons ces cas de nos analyses.↩︎ Il faudrait analyser plus en détail ces cas anormaux: peut-être que les personnes concernées exercent des professions en tant qu’indépendants et s’estiment “de garde” en permanence.↩︎ Vu qu’il ne s’agit pas d’une introduction à la programmation avec R, nous ne nous attardons pas sur l’écriture de fonctions dans R. Nous renvoyons à l’ouvrage “Introduction à la programmation en R” de Vincent Goulet et plus particulièrement au chapitre 5: “Fonctions définies par l’usager”.↩︎ Si l’on avait accès aux données de revenus comme l’a l’administration fiscale (en Belgique: SPF Finances) et les organismes de la sécurité sociale (en Belgique notamment par le biais de la BCSS), la distribution serait vraisemblablement encore plus proche de la distribution normale.↩︎ Pour les concepts d’échantillon et de population, d’intervalles de confiance, de p-valeur nous renvoyons aux ouvrages d’introduction aux statistiques. Notons que contrairement à des formulations que l’on peut trouver ça et là, les “vraies” valeurs dans la population sont et restent toujours inconnues. Les estimations que l’on peut obtenir par des procédés mathématiques ne permettent pas de connaître cette “vraie” valeur. L’on peut simplement connaître la probabilité d’obtenir une valeur dans l’intervalle calculée si l’on prend un nouvel échantillon dans la population.↩︎ Attention: Si nous travaillons avec des données qui ne sont pas transformées, il n’y pas besoin de faire une telle transformation!↩︎ Ce syllabus ne s’attarde pas sur le fonctionemnt de cet interface graphique. Vous trouverez des explications en ligne, notamment: https://lms.fun-mooc.fr/c4x/UPSUD/42001S02/asset/introRcmdr.html↩︎ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
